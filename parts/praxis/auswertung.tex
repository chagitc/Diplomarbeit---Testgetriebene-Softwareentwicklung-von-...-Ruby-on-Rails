\section{Auswertung}

* Fortschritt in der Entwicklung

\input{parts/praxis/auswertung_itjobs}
\input{parts/praxis/auswertung_benchmark}







\subsection{Eigenschaften erfolgreicher Tests -- IN ARBEIT!!}

TODO Ueberarbeitung und merging mit MSDNA Tipps und eigene Erfahrungen
%TODO 

Das Vorhandensein von zahlreichen Tests reicht nicht, um das Testen erfolgreich abzuschließen. Zur Beurteilung der Brauchbarkeit einer Testsuite genügen die folgenden Kriterien \cite[S.272-279]{rappin_rails_2011}.



\begin{description}
 \item[Unabhängigkeit (Independence)] Ein Test ist unabhängig, falls er nicht durch andere Tests beeinflusst wird. Auch die Reihenfolge, in der die Tests ausgeführt werden, darf auf das Ergebnis keinen Einfluss üben. Siehe auch \citep{beck_test_2002}.
 \item[Wiederholbarkeit (Repeatability] Ein Test wird als wiederholbar bezeichnet, wenn er mehrmals hintereinander ausgeführt werden kann, und dabei jedes mal dasselbe Ergebnis liefert. Problematisch sind dabei z.B. Datum und Zeit, sowie Zufallsfunktionen
 \item[Klarheit (Clarity)] Ein Test ist klar, wenn sein Zweck sofort verständlich wird. Damit wird einerseits die Lesbarkeit gemeint. Anderseits schließt dies auch ein, ob der Test genau eine Eigenschaft testet und nicht redundant zu anderen Tests ist. Dies hat zur Folge, dass die Tests wartbarer werden und als Code Dokumenation dienen können.
 \item[Präzise (Conciseness)] Ein Test ist präzise, wenn er so wenig Code und so wenige Objekte wie möglich benötigt, um sein Ziel zu erreichen. Eine Auswirkung ist, dass der Test schneller wird.
 \item[Robustheit (Robustness)] Ein Test ist robust, wenn es eine direkte Korrelation zum zu testenden Code gibt: Ist der Code korrekt, so ist der Test erfolgreich. Ist der Code falsch, so schlägt der Test fehl. Nicht-robuste Tests werden auch "`zerbrechlich"' (brittle) genannt. Dazu zählen auch sogenannte tautologische Tests, die immer erfolgreich Verlaufen, und keine Aussage über den zugrunde liegenden Programmcode geben
 \end{description}

% Einige dieser Punkte können durch Metriken überprüft werden. Dazu mehr im Abschnitt \ref{sec:metrics}.
%  Code Craft S 144

  
  \subsection{Vorteile von TDD}
   
  Die Test-Suite, die durch TDD entsteht, kann als zusätzliche Dokumentation dienen, die nie veraltet, im Gegensatz zu einer geschriebenen Dokumentation \citep{palermo_guidelines_2006}.
  
  Die Software-Engineering Literatur ist sich einig, dass ein Bug teurer wird, je später er gefunden wird \citep{hunt_pragmatic_1999}[S. 238]. TDD hilft somit, einen Bug so frühzeitig wie möglich zu entdecken, und hat so das Potenzial, Budget einzusparen.
  
  Softwaresysteme, die durch TDD entstehen, tendieren dazu deutlich besser designt, lose gekoppelt und besser wartbar zu sein \citep{beck_test_2002} \citep{palermo_guidelines_2006}, da Refaktorisierungen mit hoher Zuversicht durchgeführt werden können
  
  Zusammenfassend führt TDD zu einer erhöhten Produktivität, da das Maß an manuellen Tests reduziert wird und Debuggen deutlich weniger wird \citep{palermo_guidelines_2006}.
  
  \subsection{Nachteile und Grenzen von TDD}
  Es gibt bestimmte Programmieraufgaben, die nicht allein durch die testgetriebene Entwicklung implementiert werden können. So seinen Nebenläufigkeit oder Software Sicherheit genannt, in denen TDD als Zielgeber nicht ausreiche \citep[S. xii]{beck_test_2002}.
  
  Zudem stelle die Testgetriebene Entwicklung kein Ersatz für andere Arten von Tests, wie Performanz/Stress und Usability-Test \citep[S. 86]{beck_test_2002}.
    % TODO Beispiel oder besser noch in die Auswertung
    
%     Darach’s Challenge
% Darach Ennis has thrown down a gauntlet for extending the reach of TDD. He says:
% For example, there are a lot of fallacies blowing around various engineering orga-
% nizations and amongst various engineers that this book could help to dispell and
% some of these are:
% •You can’t test GUIs automaticaly (eg: Swing, CGI, JSP/Servlets/Struts)
% •You can’t unit test distributed objects automaticaly (eg: RPC and Messaging
% style, or CORBA/EJB and JMS)
% •You can’t test-first develop your database schema (eg: JDBC?)
% •There is no need to test third party or code generated by external tools
% •You can’t test first develop a language compiler / interpreter from BNF to
% production quality implementation
% 
% 
% 
% 
% Microsoft Vorgehensweise:
% 
% Start TDD from the beginning of projects. Do not stop in the middle and claim it
% doesn’t work. Do not start TDD late in the project cycle when the design has already
% been decided and majority of the code has been written. TDD is best done
% incrementally and continuously.
% For a team new to TDD, introduce automated build test integration towards the second
% third of the development phase—not too early but not too late. If this is a “Greenfield”
% project, adding the automated build test towards the second third of the development
% schedule allows the team to adjust to and become familiar with TDD. Prior to the
% automated build test integration, each developer should run all the test cases on their
% own machine.
% Convince the development team to add new tests every time a problem is found, no
% matter when the problem is found. By doing so, the unit test suites improve during the
% development and test phases.
% Get the test team involved and knowledgeable about the TDD approach. The test team
% should not accept new development release if the unit tests are failing.
% Hold a thorough review of an initial unit test plan, setting an ambitious goal of having
% the highest possible (agreed upon) code coverage targets.
% Constantly running the unit tests cases in a daily automatic build (or continuous
% integration); tests run should become the heartbeat of the system as well as a means to
% track progress of the development. This also gives a level of confidence to the team
% when new features are added.
% Encourage fast unit test execution and efficient unit test design. Test execution speed is
% very important since when all the tests are integrated, the complete execution can
% become quite long for a reasonably-sized project and when using constant test
% executions. Tests results are important early and often; they provide feedback on the
% current state of the system. Further, the faster the execution of the tests the more likely
% developers themselves will run the tests without waiting for the automated build tests
% results. Such constant execution of tests by developers may also result in faster unit
% tests additions and fixes.
% Share unit tests. Developers’ sharing their unit tests, as an essential practice of TDD,
% helps identify integration issues early on.
% Track the project using measurements. Count the number of test cases, code coverage,
% bugs found and fixed, source code count, test code count, and trend across time, to
% identify problems and to determine if TDD is working for you.
% Check morale of the team at the beginning and end of the project. Conduct periodical
% and informal surveys to gauge developers’ opinions on the TDD process and on their
% willingness to apply it in the future.
