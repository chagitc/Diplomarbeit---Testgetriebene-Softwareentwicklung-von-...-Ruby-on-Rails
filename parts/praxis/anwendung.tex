\section{Anwendung der Testgetriebenen Entwicklung}

In den nachfolgenden Abschnitten wird examplarisch an dem Objekt "`Job"', also einer Stellenanzeige, die Testgetriebene Entwicklung näher erläutert.
    
    
\subsection{Implementierung von Unit-Tests in Form von Modelltests}    

Ein Modell repräsentiert die Daten der Anwendung, und die Regeln, wie diese zu verändern sind. Bei Rails werden sie hauptsächlich dazu verwendet, um mit der zugrundeliegenden Datenbanktabelle zu interagieren. Per Konvention von Rails findet hier die Hauptarbeit, also die Business-Logik, statt.

Fast jeder Unittest bei Rails überprüft Validierungskritieren seines korrespondierenden Modells, d.h. wann eine Instanz dieses Modells gültig ist und damit gespeichert werden darf (man denke z.B. an Pflichtfelder für ein Modell "`Nutzer"` oder die Validierung des Formates seiner E-Mail-Adresse). Daneben sollten natürlich alle weiteren, selbstdefinierten, Methoden getestet werden.
% TODO http://guides.rubyonrails.org/getting_started.html#the-mvc-architecture

\paragraph{1. Der Anfang}
\begin{figure}[h]
 \centering
 \includegraphics[width=0.3\textwidth]{../diagrams/job-erm.png}
 % job-erm.png: 173x186 pixel, 51dpi, 8.65x9.30 cm, bb=0 0 245 264
 \caption{Attribute des Modells "`Job"'}
  \label{fig:job-erm}
\end{figure}

Während der Analyse wurden die benötigten Attribute bestimmt. In Abbildung \ref{fig:job-erm} seien die Basisattribute der Tabelle dargestellt. Neben den einfachen Attributen, wie Title, Description und Link, existieren auch Referenzen auf andere Objekte (d.h. dies stellen Fremdschlüssel zu anderen Tabellen dar), wie z.B. Schlagwörter (Tags), ein Besitzer einer Stellenanzeige (User) und so weiter.


In der Regel erfolgt nun eine Generation der Testklasse und des Testmodells mittels der mitgelieferten Codegeneratoren. 
\begin{lstlisting}
~/it-jobs$ rails generate model job title:string link:string \
    description:text user:references visible:boolean ...

      invoke  active_record
      create    db/migrate/20110828160636_create_jobs.rb
      create    app/models/job.rb
      invoke    test_unit
      create      test/unit/job_test.rb
      create      test/fixtures/jobs.yml

\end{lstlisting}
Mit der Anweisung uns ein Modell "'job"` mit den nachfolgenden Attributen zu generieren, hat Rails uns nun schon ein Stück Arbeit abgenommen. Es wurden erstellt:
\begin{itemize}
 \item Eine Migration (\verb|db/migrate/2011xxxxxx_create_jobs.rb|). Dies stellt eine datenbankunabhängige Repräsentation einer Änderung an der Struktur unserer Datenbank dar. In diesem ist es die Erstellung einer Tabelle "'jobs"` (beachte: Plural!)
 \item Die Modelklasse (\verb|app/models/job.rb|)
 \item Die dazugehörige Testklasse (\verb|app/unit/job_test.rb|)
 \item und Fixtures-Datei (\verb|test/fixtures/jobs.yml|), zur Definition von Testdaten. 
\end{itemize}


Nach einer Erstellung der (SQLite)-Datenbank und Ausführung der Migration kann die Rails-Test-Suite nun auch schon ausgeführt werden:

\begin{lstlisting}
$ rake db:migrate && rake test
 
==  CreateJobs: migrating =====================================================
-- create_table(:jobs)
   -> 0.0020s
==  CreateJobs: migrated (0.0021s) ============================================

(in /home/zealot64/TEST)
Loaded suite /usr/lib/ruby/gems/1.8/gems/rake-0.8.7/lib/rake/rake_test_loader
Started
.
Finished in 0.043818 seconds.

1 tests, 1 assertions, 0 failures, 0 errors

\end{lstlisting}

Es wurde also schon ein Testfall erfolgreich ausgeführt, nämlich ein Dummytestfall von Rails:

\begin{lstlisting}[language=ruby]
test/unit/job_test.rb 
require 'test_helper'

class JobTest < ActiveSupport::TestCase
  # Replace this with your real tests.
  test "the truth" do
    assert true
  end
end
\end{lstlisting}

\begin{ruby}[label={test/units/job\_test.rb}]
\PY{c+c1}{#test/unit/job\PYZus{}test.rb }
\PY{n+nb}{require} \PY{l+s+s1}{'test\PYZus{}helper'}

\PY{k}{class} \PY{n+nc}{JobTest} \PY{o}{<} \PY{n+no}{ActiveSupport}\PY{o}{::}\PY{n+no}{TestCase}
  \PY{c+c1}{# Replace this with your real tests.}
  \PY{n+nb}{test} \PY{l+s+s2}{"}\PY{l+s+s2}{the truth}\PY{l+s+s2}{"} \PY{k}{do}
    \PY{n}{assert} \PY{k+kp}{true}
  \PY{k}{end}
\PY{k}{end}
\end{ruby}
\label{list:bla}
\captionsetup{type=lstlisting}
\caption{Listing Test}


\paragraph{2. Testen auf Validierung}

Ein Feature von Rails umfassen die sogenannten Validierungen. Diese stellen sicher, dass eine Instanz eines Modells nur dann gespeichert ist, wenn es gewissen Kritieren entspricht. Viele der Validations sind vergleichbar mit den Datenbank-Constraints einiger Datenbanken. Rails nutzt diese standardmäßig nicht, da es auch andere Persistenzsysteme unterstützt, wie z.B. Key-Value-Store, sogenannte NoSQL Datenbanken. So stellt Rails die Konsistenz und referenzielle Integrität innerhalb der Applikationsschicht sicher.

Nun möchten wir sicherstellen, dass eine Stellenanzeige nur dann gespeichert wird, wenn sie einen Titel beinhaltet. Der Test dazu würde wie folgt lauten:

\begin{lstlisting}
test/unit/job_test.rb 
require 'test_helper'

class JobTest < ActiveSupport::TestCase
  test "ein Job muss einen Titel haben" do
    job = Job.new
    job.title = nil
    assert !job.save
  end
end
\end{lstlisting}
\tddred
Zuerst instanziieren wir einen Job, und geben ihm explizit einen leeren Titel, um das Testziel nochmal herauszustellen. Danach sichern wir zu, dass eine Speicherung nicht erfolgt, also "`false"' ist.

Nach Ausführung des Tests, schlägt dieser wie zu erwarten fehl.

Unser nächstes Ziel ist es nun, mit so wenig Code wie möglich den Test bestehen zu lassen. Das können wir mittels der eingebauten wie schon erwähnten Validierungen:


\begin{lstlisting}
class Job < ActiveRecord::Base
  validates :title, :presence => true
end
\end{lstlisting}
\tddgreen
Nach erneuter Ausführung der Testsuite, besteht der Test nun. Jetzt folgt die Refaktorisierungsphase. Der Programmcode lässt sich nicht weiter vereinfachen. Aber der Testcode ist ausdrücklich nicht von Refaktorisierungen befreit, und eine Refaktorisierung wäre z.B.:
\tddrefactor
\begin{lstlisting}
test "ein Job muss einen Titel haben" do
  job = Job.new :title => nil
  assert !job.save
end
\end{lstlisting}



Nun wollen wir dasselbe für das Feld E-Mail tun, hierbei aber nicht nur das Vorhandensein prüfen, sondern auch das Format.

\begin{lstlisting}
test "ein Job muss eine gültige E-Mail haben" do
  job = Job.new :email => "invalid_email"
  assert !job.save
end
\end{lstlisting}
\tddred
Die Implementierung wäre dann:
\begin{lstlisting}
class Job < ActiveRecord::Base
  validates :email, :format => /^[\w\d_\-]+@[\w\d_\-]\.[\w\d]{2,3}$/
  ...
\end{lstlisting}
\tddgreen
Eine Refaktorisierung ist aufgrund der Einfachheit der Beispiel hier nur gering möglich. Man könnte z.B. den regulären Ausdruck, der das Format der E-Mail Adresse beschreibt in eine neue Klasse oder zumindest eine Konstante auslagern. Wir wählen eine Konstante, die beim Laden von Rails bereitgestellt wird.
\tddrefactor
\begin{lstlisting}
# config/initializers/regex.rb
REGEX_EMAIL_FORMAT = /^[\w\d_\-]+@[\w\d_\-]\.[\w\d]{2,3}$/

# app/models/job.rb
class Job < ActiveRecord::Base
  validates :email, :format => REGEX_EMAIL_FORMAT
  ...
\end{lstlisting}
Ein erneutes Ausführen der Tests betätigt den Erfolg der Refaktorisierung.

\paragraph{3. Refaktorisierungen der Testklasse}
Nun fehlt aber noch die Definition eines Positiv-Beispiel für einen gültigen Job.

\begin{lstlisting}
test "ein Job muss einen Titel haben" do
  job = Job.new :title => "Rails Entwickler", :email => "info@stefanwienert.net"
  assert_valid job
end
\end{lstlisting}
\tddgreen
Dieser Test besteht sofort, macht also genau genommen keine weitere Aussage über unser System. Nach der "`reinen"' Testgetriebenen Leere sollte dieser entfernt werden. Es ist allerdings eine gute Strategie, bei Validierungen mindestens ein Beispiel zu präsentieren, dass angenommen wird. Nichtsdestotrotz können wir nun Refaktorisieren. Insbesondere unsere Testfunktionen enthalten unnötige Redundanzien:

\begin{lstlisting}
test "ein Job muss einen Titel haben" do
  job = Job.new :title => nil
  assert !job.save
end
test "ein Job muss eine gültige E-Mail haben" do
  job = Job.new :email => "invalid_email"
  assert !job.save
end
test "ein Job muss einen Titel haben" do
  job = Job.new :title => "Rails Entwickler", :email => "info@stefanwienert.net"
  assert_valid job
end
\end{lstlisting}
\tddrefactor
In allen drei Methoden wird ein Job instanziiert, und lediglich verschiedene Attribute überprüft. Auch haben unsere ersten beiden Tests keine gültige Aussage mehr, da der jeweilige Job sowieso nicht gültig ist, da jeweils das andere Attribut fehlt\footnote{Im ersten Test ist nicht nur der Titel nicht gesetzt, sondern auch die E-Mail entspricht nicht dem Format}. Es ist also höchste Zeit, die Tests zu refaktorisieren. Dies geschieht am Besten durch die Verwendung einer Testdaten-Generation, z.B. den eingebauten Fixtures, die Rails uns bei der Codegeneration schon mit generiert hatte. Dabei definieren wir zentralisiert unsere (gültigen) Testdaten, die von Rails vor jedem einzelnen Test in der Datenbank bereitgestellt werden:

\begin{lstlisting}
# test/fixtures/jobs.yml
valid_job:
  title: Rails Entwickler
  email: info@stefanwienert.net
  link: http://www.example.com/jobs
  visible: true
  ...
invisible_job:
  title: Rails Entwickler
  visible: false
  ...
  
  
\end{lstlisting}

Nun können wir diese Fixtures in unseren Tests verwenden, und das ganze in einer setup-Methode, die vor jedem Testfall aufgerufen wird, laden:
\begin{lstlisting}
setup do
  @job = jobs :valid_job
  # Dies lädt den Job mit dem Schlüssel "valid_job"
  #  und schreibt ihn in die Instanzvariable @job
  #  der Testklasse 
end

test "stelle sicher, dass die Fixtures valide sind" do
  assert_valid @job
end
test "ein Job muss einen Titel haben" do
  @job.title = nil
  assert !@job.save
end
test "ein Job muss eine gültige E-Mail haben" do
  @job.email = "invalid_email"
  assert !@job.save
end
\end{lstlisting}
\tddrefactor
Am Ende dieser Refaktorisierungen ist es notwendig, die Tests noch einmal auszuführen.
Danach würde die Implementierung einer nächsten Teilanforderung sein. Was in diesem Abschnitt zu sehen war ist, dass die Testgetriebene Entwicklung das Arbeiten und Testen in kleinen Schritten favorisiert.
\tddgreen

\subsection{Implementierung von Controller-Tests (functional tests)}

Neben den Unittests stellt Ruby on Rails eine weitere Testart nativ bereit. Technisch gesehen handelt es sich bei diesen Functional Tests aber auch um Unittests, da deren Testobjekt ein Controller ist. 
Ein Controller hat bei Ruby on Rails die Aufgabe, Anfragen für bestimmte Routen, also Web-Adressen, anzunehmen, die Arbeit an eine Modelklasse auszulagern, und eine View aufzurufen, die letztendlich HTML-Code generiert.

Im ersten Beispiel wollen wir testen, dass ein Gast-Nutzer, also z.B. ein Bewerber, eine sichtbare Stellenanzeige aufrufen darf (visible = true). Hierbei verwenden wir wieder unser oben definiertes Fixture für einen gültigen Job.
\begin{lstlisting}
/test/functional/jobs_controller_test.rb 
require 'test_helper'

class JobsControllerTest < ActionController::TestCase
  test "Gast Nutzer kann Stellen betrachten" do
    session[:user_id] = nil
    job = jobs(:valid_job)
    
    get :show, :id => job.id
    
    assert_response :success
    assert_equal job, assigns(:job)
  end
end
\end{lstlisting}
\tddred
Zuerst loggen wir jeglichen Nutzer aus, der eventuell eingeloggt war, dann laden wir das Fixture und führen einen simulierten HTTP Request auf die Detailansicht der Stellenanzeige aus (Die Aktion "`show"' mit der ID des Jobs).
Nun erwarten wir, dass wir einen HTTP-Status Code 200 (success) erhalten, und dass der Controller eine Variable "`@jobs"' bereitstellt, die mit unserem Fixture identisch ist.

Die Implementation dieser Anforderung könnte wie folgt umgesetzt werden:
\begin{lstlisting}
# app/controllers/jobs_controller.rb
class JobsController < ApplicationController
  ...
  def show
    @job = Job.first
  end
  ...
  
end
\end{lstlisting}
\tddgreen
Das Laden des erstem Jobs aus unserer Datenbank genügt zum Erfüllen der Anforderungen, und ist ein schneller Weg, den Test bestehen zu lassen. Allerdings handelt es sich hierbei um eine Fake-Implementierung, da zwar unser Test erfüllt wird, aber die Anwendung nicht das macht, was man sich erhofft hat. Solche Zwischenschritte sind aber ausdrücklich vorgesehen, da das Ziel ist, so schnell wir möglich einen funktionierenden Test zu erhalten mit dem man arbeiten kann.

Wenn wir nun weitere Tests schreiben, so wird es immer schwieriger, die Fake-Implementierung beizubehalten, und früher oder später wird eine korrekte Implementierung folgen. 
Aber wir können auch die nun folgende Refaktorisierungsphase nutzen, um diesen Makel zu beseitigen:
\tddrefactor
\begin{lstlisting}
# app/controllers/jobs_controller.rb
def show
  @job = Job.find(params[:id])
end
\end{lstlisting}

Nun wollen wir testen, ob ein Gast von einer nicht-sichtbaren Stellenanzeige weitergeleitet wird und einen Hinweis erhält.

\begin{lstlisting}
test "Gast Nutzer kann nicht-sichtbare Stellen nicht betrachten" do
  session[:user_id] = nil
  job = jobs(:invisible_job)
  
  get :show, :id => job.id

  assert_response :redirect
  assert flash[:notice].present?
end
\end{lstlisting}
\tddred

Wir laden unser zweites definiertes Fixture, dass eine unsichtbaren Stellenanzeige. Dieses mal erwarten wir einen HTTP Statuscode 301 (Redirect), und dass unser Controller eine Hinweisnachricht generiert.

\begin{lstlisting}
def show
  @job = Job.find(params[:id])
  if not @job.visible?
    redirect_to root_path, :notice => "Diese Stelle ist zur Zeit nicht sichtbar"
  end
end
\end{lstlisting}
\tddgreen
Falls der aktuelle Job nicht sichtbar ist, dann erfolgt eine Weiterleitung auf die Startseite und die Bereitstellung des Hinweistextes.
\tddrefactor
Da auch hier der Quelltext wieder sehr kurz ist, ist ein Refaktorisieren nicht notwendig.

Nun möchten wir, dass ein Kunde dieser Anwendung, also ein Unternehmen seine Stellenanzeige betrachten kann, auch wenn diese unsichtbar ist, sei es aus Gründen der Archivierung als auch der Vorbereitung für eine Veröffentlichung.

\begin{lstlisting}
test "Ein Kunde darf aber seine unsichtbaren Jobs betrachten" do
  job = jobs(:invisible_job)
  session[:user_id] = job.user_id
  
  get :show, :id => job.id

  assert_response :success
end
\end{lstlisting}
\tddred
Über die globale Session Variable simulieren wir das Einloggen durch setzen der UserID in dieses Array. Die genaue Implementation hängt natürlich davon ab, wie man die Authentifizierung implementiert hat, oder welche Bibliothek man verwendet. In diesem Beispiel sei darauf hingewiesen, dass die Definition, ob ein Nutzer eingeloggt ist oder nicht, davon abhängt, ob in seiner Session-Variable eine UserID enthalten ist.

\begin{lstlisting}
def show
  @job = Job.find(params[:id])
  if !@job.visible? and @job.user != User.find(session[:user_id])
    redirect_to root_path, :notice => "Diese Stelle ist zur Zeit nicht sichtbar"
  end
end
\end{lstlisting}
\tddgreen
Wir lösen diesen Test damit, dass wir in der Weiterleitungsbedingung prüfen, ob der betrachtende Nutzer und der Eigentümer des Jobs gleich sind.

Nun können wir refaktorisieren. Was auffällt, ist z.B. dass unser Controller und die Klasse Job nicht lose gekoppelt sind, da die Bedingung zweimal auf Attribute des Jobs zurückgreift. Eine Lösung wäre die Auslagerung in die Modelklasse von Job:
\tddrefactor
\begin{lstlisting}
# app/models/job.rb
class Job < ActiveRecord::Base
  ...
  def visible_for_user?(user)
    self.visible and self.user != user
  end 
end

# app/controllers/jobs_controller.rb 
def show
  @job = Job.find(params[:id])
  unless @job.visible_for_user?(User.find(session[:user_id]))
    redirect_to root_path, :notice => "Diese Stelle ist zur Zeit nicht sichtbar"
  end
end
\end{lstlisting}
Ebenfalls wurde das syntaktische Element "`unless"' verwendet, welches ein Alias für "`if not"' ist.
Weiterhin könnte die Suche nach dem aktuell eingeloggten Nutzer in eine für alle Controller sichtbare Funktion ausgegliedert werden
\tddrefactor
\begin{lstlisting}

# app/controllers/application_controller.rb
...
  def current_user
    User.find(session[:user_id]
  end

# app/controllers/jobs_controller.rb 
def show
  @job = Job.find(params[:id])
  unless @job.visible_for_user? current_user
    redirect_to root_path, :notice => "Diese Stelle ist zur Zeit nicht sichtbar"
  end
end
\end{lstlisting}


% Funktionale Tests sind in Rails häufig recht einfach gehalten, da das Ziel vergo
\borderquote{Skinny Controller, Fat Model [...] Try to keep your controller actions and views as slim as possible.}{Jamis Buck, Programmierer bei 37signals}
Funktionale Tests und deren Controllerimplementierungen sind häufig nischt länger als ein paar Zeilen. Qua Konventation des MVC-Patterns und Rails sollen komplexe Abläufe in den Modellen oder auch in Bibliotheken stattfinden. 
Die Aspekte, die üblicherweise bei Controllern getestet werden, sind:
\begin{itemize}
 \item HTTP Statuscodes und Weiterleitungen,
 \item das Vorhandensein von Statusmeldungen, gennant "`Flash"' Messages
 \item dass ein bestimmtes Template geladen wird
 \item dass Instanzvariablen gesetzt werden, die die View später darstellen sollen
 \item falls man Viewtests mit einschließt, dann wird u.U. auch auf das Vorhandensein von bestimmten HTML-Elementen in der am Ende generierten View getestet. Z.B. möchte man wissen, ob das Überschriftenelement "`h1"' dem Job-Titel entspricht, wenn man dieDetailansicht eines Jobs aufruft.
\end{itemize}



\subsection{Testen von externen Abhängigkeiten}
Fast alle Webapplikationen sind auf Kommunikation mit anderen Servern angewiesen. Als Beispiel seien die diversen APIs der sozialen Netzwerke genannt oder Webservices. Für die vorliegende Jobanwendung war gewünscht, ein Feedimport-Feature zu implementieren, sodass bestimmte Kunden ihre Stellenanzeigen automatisiert einlesen lassen könnten.

Die genannten Partner stellen einen XML-Feed nach dem RSS 2.0 Format\footnote{Spezifikation des RSS 2.0 Formats: \url{http://cyber.law.harvard.edu/rss/rss.html}} bereit, der ein häufig verwendetes Format zum Austausch von Informationen ist, und durch eine Vielzahl von Werkzeugen und Content-Management-Systemen unterstützt wird.
Dabei wird der Inhalt des Haupttextfeldes "`description"' um weitere Informationen in einem Subdialekt angereichert. 
 
Im Nachfolgenden sei z.B. eine Stellenanzeige in dem Format beschrieben:

\begin{ruby}[label=beispiel\_job.xml, fontsize=\relsize{-2}]
\PY{c+cp}{<?xml version="1.0" encoding="UTF-8"?>}
\PY{n+nt}{<rss} \PY{n+na}{version=}\PY{l+s}{"2.0"}\PY{n+nt}{>}
  \PY{n+nt}{<channel}\PY{n+nt}{>}
    \PY{n+nt}{<title}\PY{n+nt}{>}RSS Feed für Jobangebote \PY{n+nt}{</title>}
    \PY{n+nt}{<language}\PY{n+nt}{>}de\PY{n+nt}{</language>}
    \PY{n+nt}{<item}\PY{n+nt}{>}
      \PY{n+nt}{<title}\PY{n+nt}{>}Softwareentwickler Java/JEE (m/w)\PY{n+nt}{</title>}
      \PY{n+nt}{<description}\PY{n+nt}{>}
        \PY{c+cp}{<![CDATA[}
\PY{c+cp}{        <!--}
\PY{c+cp}{        <nummer>example\PYZus{}job\PYZus{}01</nummer>}
\PY{c+cp}{        <tags>Java,Webentwickler,Softwareentwickler</tags>}
\PY{c+cp}{        <ort>Dresden</ort>}
\PY{c+cp}{        <kontakt>Max Mustermann bewerbung@example.com</kontakt>}
\PY{c+cp}{        <link>http://www.example.com/jobs/512.html</link>}
\PY{c+cp}{        -->}
\PY{c+cp}{        Zur Verstärkung unseres Teams suchen wir zum nächstmöglichen}
\PY{c+cp}{        Zeitpunkt einen Softwareentwickler Java/JEE (m/w) zur Festanstellung.<br />}
\PY{c+cp}{        Ihre Aufgaben: ...}
\PY{c+cp}{        ]]>}
      \PY{n+nt}{</description>}
      \PY{n+nt}{<link}\PY{n+nt}{>}http://www.example.com/jobs/512.html\PY{n+nt}{</link>}
      \PY{n+nt}{<pubDate}\PY{n+nt}{>}Wed, 25 Mar 2011 13:30:00 +0100\PY{n+nt}{</pubDate>}
      \PY{n+nt}{<guid}\PY{n+nt}{>}example\PYZus{}job\PYZus{}01\PY{n+nt}{</guid>}
    \PY{n+nt}{</item>}
  \PY{n+nt}{</channel>}
\PY{n+nt}{</rss>}
\end{ruby}
\captionsetup{type=lstlisting}
\caption{Feedimport Beispiel-XML Datei mit einem Job}
Der RSS-Feed in dem oben genannten Beispiel enthält eine Stellenanzeige (item). Die description beinhaltet einen HTML-Kommentar, in dem nummer, tags, ort, kontakt und link für die Stellenanzeige definiert werden. Das ganze wurde mit einem Kommentar, und nicht mit einer Erweiterung der Syntax durch eine DDT oder XSD realisiert, da die Personen, die den Feed pflegen werden, in seltenen Fällen IT-Personal sind, sondern Personalmitarbeiter. Auch hat sich eine Eingliederung mittels DDTs und XSDs bei einigen der CMS der Kunden als problematisch herausgestellt.



 
 
 mittels Mocks und Stubs am Beispiel Feedimport

\subsection{System und Akzeptanztests}
Cucumber Outside-In Development


\subsection{Testen von Javascript Ereignissen}
\subsubsection{Test im Rahmen von Integrationstest}
Systemtests mittels Selenium fuer vereinzeltes JS in Form von

\subsubsection{Unittests mit Javascript}
Unittests:  Jasmine fuer komplexe Objekte und Javascript Anwendungen






