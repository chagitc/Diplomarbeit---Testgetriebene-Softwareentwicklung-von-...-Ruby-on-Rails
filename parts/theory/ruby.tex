\section{Die Programmiersprache Ruby}

Ruby ist eine Programmiersprache, die ab 1993 von Yukihiro Matsumoto entwickelt wurde. Dabei ließ er sich von seinen Lieblingsprogrammiersprachen Perl, Smalltalk, Eiffel, Ada und Lisp inspirieren, um eine neue Programmiersprache zu entwickeln, die sowohl funktionale und imperative Programmierung ermöglicht \citep{ruby_visual_identity_team_about_2011}. 

Eine vollständige Einführung in Ruby zu geben würde den Rahmen dieser Diplomarbeit sprengen, weswegen ich mich auf die Herausstellung der Hauptmerkmale und Unterschiede zu anderen Sprachen konzentrieren werde, und was die Auswirkungen auf das Testgeschehen sind.

\subsection{Einführung in Ruby}
\marginline{\includegraphics[width=0.8\marginparwidth]{material/ruby.png}
Ruby ist eine Multiparadigma-Sprache}
Ruby ist eine interpretierte Sprache, auch Skriptsprache genannt. Dies heisst, dass der Programmcode zur Laufzeit analysiert und ausgeführt wird. Ruby ist auch eine Multiparadigma-Sprache, die Objektorientierung, prozedurale und funktionale Programmierung unterstützt.
\begin{description}
 \item[Prozedural] Funktionen und Variablen können außerhalb von Klassen definiert werden, in dem sogenannten "`main"'-Objekt
 \item[Objektorientierung] Alle Datentypen sind Objekte. Alle Variablen beinhalten Referenzen auf ein Objekt. Dies betrifft auch die primitiven Datentypen wie Integer und String
 \item[Funktional] Anonyme Funktionen und Closures sind Sprachbestandteil. Alle Statements haben einen Rückgabewert. Innerhalb einer Funktion ist dies immer das letzte Statement, falls kein expliziter Rücksprungpunkt gesetzt wurde
\end{description}


Das Ziel von Ruby ist es nicht nur Maschinenlesbarkeit zu sein, sondern vor allem die Lesbarkeit durch Menschen zu verbessern. Dies drückt sich durch eine Syntax, die oft laut als englische Sprache gelesen werden kann, aus, und den Einsatz von Sonderzeichen reduziert. Auch hält Ruby eine Vielzahl von redundanten Keywords bereit (Syntaktischer Zucker), um dem Programmierer mehrere Wege zur Lösung seines Problems zu ermöglichen.

\setlength{\epigraphwidth}{\marginparwidth}
\marginline{\epigraph{Ruby is simple in appearance, but is very complex inside, just like our human body}{Yukihiro Matsumoto}}
\setlength{\epigraphwidth}{0.8\textwidth}

Im Nachfolgenden einige Beispiele für die Verwendung von Ruby, insbesondere die "`Alles ist ein Objekt"'-Philosophie.

 \begin{ruby}[label=Interaktive Ruby Sitzung (IRB)]
  \PY{g+gp}{>> }\PY{l+m+mi}{2}\PY{o}{.}\PY{n}{even?}
  \PY{g+go}{=> true}
  \PY{g+gp}{>> }\PY{l+s+s2}{"}\PY{l+s+s2}{hallo}\PY{l+s+s2}{"}\PY{o}{.}\PY{n}{upcase}
  \PY{g+go}{=> "HALLO"}
  \PY{g+gp}{>> }\PY{n+no}{Date}\PY{o}{.}\PY{n}{today} \PY{o}{+} \PY{l+m+mi}{2}
  \PY{g+go}{=> #<Date: 2011-06-30>}
  \PY{g+gp}{>> }\PY{n}{a} \PY{o}{=} \PY{l+m+mi}{4} \PY{o}{+} \PY{n+no}{Math}\PY{o}{.}\PY{n}{sqrt}\PY{p}{(}\PY{l+m+mi}{9}\PY{p}{)}
  \PY{g+go}{=> 7.0}
  \PY{g+gp}{>> }\PY{k}{if} \PY{p}{(}\PY{l+m+mi}{0}\PY{o}{.}\PY{n}{.}\PY{l+m+mi}{10}\PY{p}{)}\PY{o}{.}\PY{n}{include?} \PY{n}{a}
  \PY{g+gp}{>> }  \PY{n+nb}{puts} \PY{l+s+s2}{"}\PY{l+s+s2}{a liegt zwischen 0 und 10}\PY{l+s+s2}{"}
  \PY{g+gp}{>> }\PY{k}{end}
  \PY{g+go}{=> a liegt zwischen 0 und 10}
 \end{ruby}
\codecaption{Ruby Beispiele}

In den ersten beiden Beispielen sieht man, dass Integer und String Objekte sind, und über Memberfunktionen verfügen. Im ersten Beispiel wird geprüft, ob die Zahl gerade ist. Dabei existiert eine Konvention, dass boolsche Methoden mit einem Fragezeichen am Ende notiert werden. Im Dritten Beispiel wird eine Klassenmethode "`today"' auf die Klasse "`Date"' ausgeführt, welche ein Datumsobjekt konstruiert und zurückliefert. Da auch die Nutzung von Operatoren letzendlich in Methodenaufrufe gemappt werden, wird die Methode "`.+(2)"' auf dieses Objekt ausgeführt, und liefert ein neues Datumsobjekt, welches sich um 2 Tage unterscheidet, zurück.
Im Vierten Beispiel wird der Einsatz von Variablen demonstriert. 
Das letzte Beispiel zeigt den Einsatz von Kontrollstrukturen. Als Besonderheit seien hier auf die Range "`(0..10)"', die ein Intervall für den Integerzahlenbereich von 0 bis einschließlich 10 liefert. Die Methode "`.include?(a)"' tests nun, ob die Variable "`a"' in diesem Intervall existiert. Bei Eindeutigkeit können die Klammern eines Methodenaufrufes weggelassen werden.

Weiterhin erlaubt Ruby die Arbeit mit Lambdas, also anonymen Funktionen. Eine beliebte Verwendungsmöglichkeit ist die Bearbeitung von Arrays und listenähnlichen Strukturen.

% SNIPPET: [language=Ruby,label=Ruby Beispiel: Lambdas,caption=Ruby Beispiel: Lambdas]
% >> adder = lambda { |a,b|  a + b }                                                                                                         
% >> adder.call(1,2)                                                                                                                         
% => 3                                                                                                                                       
%                                                                                                                                            
% # Sortiere nach Standardvergleichsoperator                                                                                                 
% >> [4,5,7,3].sort()                                                                                                                        
% => [3, 4, 5, 7]                                                                                                                            
%                                                                                                                                            
% # Es kann auch eine benutzerdefinierte Sortierfunktion                                                                                     
% # angegeben werden                                                                                                                         
% >> [ "string",  "rails",  "ruby" ].sort_by{ |item| item.length }                                                                           
% => ["ruby", "rails", "string"]                                                                                                             
%                                                                                                                                            
% # Die Quadratzahlen von 1 bis 5                                                                                                            
% >> (1..5).map{|element| element * 2}                                                                                                       
% => [2, 4, 6, 8, 10]                                                                                                                        
%                                                                                                                                            

\begin{ruby}[label=IRB]
\PY{g+gp}{>> }\PY{n}{adder} \PY{o}{=} \PY{n+nb}{lambda} \PY{p}{\PYZob{}} \PY{o}{|}\PY{n}{a}\PY{p}{,}\PY{n}{b}\PY{o}{|}  \PY{n}{a} \PY{o}{+} \PY{n}{b} \PY{p}{\PYZcb{}}
\PY{g+gp}{>> }\PY{n}{adder}\PY{o}{.}\PY{n}{call}\PY{p}{(}\PY{l+m+mi}{1}\PY{p}{,}\PY{l+m+mi}{2}\PY{p}{)}
\PY{g+go}{=> 3}

\PY{g+go}{# Sortiere nach Standardvergleichsoperator}
\PY{g+gp}{>> }\PY{o}{[}\PY{l+m+mi}{4}\PY{p}{,}\PY{l+m+mi}{5}\PY{p}{,}\PY{l+m+mi}{7}\PY{p}{,}\PY{l+m+mi}{3}\PY{o}{]}\PY{o}{.}\PY{n}{sort}\PY{p}{(}\PY{p}{)}
\PY{g+go}{=> [3, 4, 5, 7]}

\PY{g+go}{# Es kann auch eine benutzerdefinierte Sortierfunktion}
\PY{g+go}{# angegeben werden}
\PY{g+gp}{>> }\PY{o}{[} \PY{l+s+s2}{"}\PY{l+s+s2}{string}\PY{l+s+s2}{"}\PY{p}{,}  \PY{l+s+s2}{"}\PY{l+s+s2}{rails}\PY{l+s+s2}{"}\PY{p}{,}  \PY{l+s+s2}{"}\PY{l+s+s2}{ruby}\PY{l+s+s2}{"} \PY{o}{]}\PY{o}{.}\PY{n}{sort\PYZus{}by}\PY{p}{\PYZob{}} \PY{o}{|}\PY{n}{item}\PY{o}{|} \PY{n}{item}\PY{o}{.}\PY{n}{length} \PY{p}{\PYZcb{}}
\PY{g+go}{=> ["ruby", "rails", "string"]}

\PY{g+go}{# Die Quadratzahlen von 1 bis 5}
\PY{g+gp}{>> }\PY{p}{(}\PY{l+m+mi}{1}\PY{o}{.}\PY{n}{.}\PY{l+m+mi}{5}\PY{p}{)}\PY{o}{.}\PY{n}{map}\PY{p}{\PYZob{}}\PY{o}{|}\PY{n}{element}\PY{o}{|} \PY{n}{element} \PY{o}{*} \PY{l+m+mi}{2}\PY{p}{\PYZcb{}}
\PY{g+go}{=> [2, 4, 6, 8, 10]}
\end{ruby}
\codecaption{Ruby Beispiel: Blöcke}
% label{fig:460d49}



\paragraph{Typ- und Objektsystem}
Wie schon erwähnt, sind bei Ruby alle Datentypen ein Objekt. Dies schließt insbesondere Klassen und primitive Datentypen mit ein, wie wir wiefolgt sehen können
% SNIPPET: 
% >> 2.class                                                                                                                                 
% => Fixnum                                                                                                                                  
% >> Fixnum.class                                                                                                                            
% => Class                                                                                                                                   
% >> Class.class                                                                                                                             
% => Class                                                                                                                                   
%                                                                                                                                            
% >> Fixnum.superclass                                                                                                                       
% => Integer                                                                                                                                 
% >> Fixnum.ancestors                                                                                                                        
% => [Fixnum, Integer, Precision, Numeric, Comparable, Object, Kernel]                                                                       
%                                                                                                                                            
\begin{ruby}[label=IRB]
\PY{g+gp}{>> }\PY{l+m+mi}{2}\PY{o}{.}\PY{n}{class} 
\PY{g+go}{=> Fixnum}
\PY{g+gp}{>> }\PY{n+no}{Fixnum}\PY{o}{.}\PY{n}{class} 
\PY{g+go}{=> Class}
\PY{g+gp}{>> }\PY{n+no}{Class}\PY{o}{.}\PY{n}{class} 
\PY{g+go}{=> Class}

\PY{g+gp}{>> }\PY{n+no}{Fixnum}\PY{o}{.}\PY{n}{superclass}
\PY{g+go}{=> Integer}
\PY{g+gp}{>> }\PY{n+no}{Fixnum}\PY{o}{.}\PY{n}{ancestors}
\PY{g+go}{=> [Fixnum, Integer, Precision, Numeric, Comparable, Object, Kernel]}
\end{ruby}
\codecaption{Klassenhierarchien}
% label{fig:f37300}

Das Literal "`2"' ist somit ein Objekt vom Typ Fixnum. Die Klasse Fixnum ist ihrerseits vom Typ "`class"'. Da Ruby sowohl (Einfach-)Ableitungen als auch sogenannte Includes oder Mixins unterstützt, kann eine Klasse auch eine Menge von Oberklassen haben. Die gezeigte Klasse Fixnum verfügt somit standardmäßig sogar über 7 Oberklassen.

Ruby ist dynamisch stark typisiert, d.h. dass die Zuweisung des Typs einer Variable zur Laufzeit des Programms geschieht. Der Typ einer Variable ergibt sich damit aus ihrem beinhalteten Objekt. Durch die starke Typisierung ist es aber nicht möglich, invalide Operationen auf inkompatible getypte Daten auszuführen, beispielsweise eine Addition von Integer mit String. Rubys Typsystem ist "`Duck-typed"', d.h. dass die Semantiken eines Objekts nicht durch seine Klasse und Ableitungshierarchie, sondern seinen Methoden und Attributen bestimmt wird.\borderquote{"When I see a bird that walks like a duck and swims like a duck and quacks like a duck, I call that bird a duck."}{James Whitcomb Riley}

Ruby verfügt über eine lexikalische und dynamische Bindung\footnote{
\textbf{Static Scoping}: Variablen werden zur Compilezeit gebunden ohne den aufrufenden Code zu berücksichtigen\\
\textbf{Dynamic Scoping}: Variablen-Bindung kann nur im Moment der Ausführung des Codes festgestellt werden}, letztere wird allerdings seltener verwendet. Im der Basissyntax verwendet Ruby statische Bindung. Es gibt eine im Ruby-Core enthaltene Bibliothek "`Dynamic"' zum dynamischen binden.


\paragraph{Reflektion und Introspection} Wichtig anzumerken sei noch, dass Klassen in Ruby nie geschlossen sind, sondern jederzeit erweitert werden können und vorhandene Methoden überschrieben werden können. So ist es z.B. möglich, die String-Klasse um eigene Funktionen zu erweitern. Ruby "`merkt"' sich allerdings die überschriebenen Methoden und ein Aufruf der überschriebenen Methoden ist stets mittels "`super"' möglich.

% SNIPPET: [language=Ruby,label=Ruby Beispiel offene Klassen,caption=Ruby Beispiel offene Klassen]
% >> class String                                                                                                                            
% >>   def remove_whitespace                                                                                                                 
% >>     self.gsub(/\s+/, "")                                                                                                                
% >>   end                                                                                                                                   
% >> end                                                                                                                                     
%                                                                                                                                            
% >> "Dies ist ein Test".remove_whitespace                                                                                                   
% => "DiesisteinTest"                                                                                                                        
%                                                                                                                                            
%                                                                                                                                         
\begin{ruby}[label=IRB]
\PY{g+gp}{>> }\PY{k}{class} \PY{n+nc}{String}
\PY{g+gp}{>> }  \PY{k}{def} \PY{n+nf}{remove\PYZus{}whitespace}
\PY{g+gp}{>> }    \PY{n+nb}{self}\PY{o}{.}\PY{n}{gsub}\PY{p}{(}\PY{l+s+sr}{/}\PY{l+s+sr}{\PYZbs{}}\PY{l+s+sr}{s+}\PY{l+s+sr}{/}\PY{p}{,} \PY{l+s+s2}{"}\PY{l+s+s2}{"}\PY{p}{)}
\PY{g+gp}{>> }  \PY{k}{end}
\PY{g+gp}{>> }\PY{k}{end}

\PY{g+gp}{>> }\PY{l+s+s2}{"}\PY{l+s+s2}{Dies ist ein Test}\PY{l+s+s2}{"}\PY{o}{.}\PY{n}{remove\PYZus{}whitespace}
\PY{g+go}{=> "DiesisteinTest"}
\end{ruby}
\codecaption{Ruby Beispiel offene Klassen}
% label{fig:9bf48b}

\paragraph{Generische Programmierung und Aspekte der Metaprogrammierung}
Metaprogrammierung umfasst die Analyse, Transformation und Generierung von Objektprogrammen durch Metaprogramme \citep{herrmann_2005}.  Dies ermöglicht es Probleme effektiv zu lösen, die andernfalls nur mit erheblichem Aufwand, oder gar nicht zu lösen sind.
Ein beliebtes Idiom innerhalb der Ruby-Community ist es, verwendete Methoden auf Basis des Methodennamens zur Laufzeit zu erstellen (Generierung). So verwendet das beliebte Objektrelationale Datenbankframework ActiveRecord dies, um einfache SQL-Statements zu erstellen (Ruby on Rails verwendet standardmäßig ActiveRecord als Schnittstelle zur Datenbank.).
% SNIPPET: 
% >> Person.find_by_first_name("Stefan")                                                                                                     
% #  Person Load (0.2ms)  SELECT persons.* FROM persons                                                                                      
% #    WHERE users.first_name = 'Stefan' LIMIT 1       
\begin{ruby}[label=IRB]
\PY{g+gp}{>> }\PY{n+no}{Person}\PY{o}{.}\PY{n}{find\PYZus{}by\PYZus{}first\PYZus{}name}\PY{p}{(}\PY{l+s+s2}{"}\PY{l+s+s2}{Stefan}\PY{l+s+s2}{"}\PY{p}{)}
\PY{g+go}{#  Person Load (0.2ms)  SELECT persons.* FROM persons}
\PY{g+go}{#    WHERE users.first\PYZus{}name = 'Stefan' LIMIT 1}
\end{ruby}
\codecaption{Demonstration von generischen}
% label{fig:d0ee1e}


Die Methode \texttt{find\_by\_first\_name} existiert nicht, und wird zur Laufzeit auf Basis des Namens gebaut. Dies ist möglich, da Ruby sogennante Hooks (Callbacks) bereitstellt. Dies sind z.B. method\_missing, der aufgerufen wird, wenn ein nicht-existierende Funktion gerufen wird (wie in unserem Beispiel "`find\_by\_first\_name"'), oder "`method\_added"', der aufgerufen wird, wenn in einer Klasse eine Methode definiert wird\footnote{Einen guten Überblick über die Callbacks die Ruby bereitstellt, und was man damit kann, finden sie hier: \url{method_added}}.

Ein weiteres Beispiel ist die Definition der relationalen Beziehungen zwischen den einzelnen Modellen innerhalb von \glossar{rails}.
\begin{ruby}[label=app/models/job.rb]
\PY{k}{class} \PY{n+nc}{Job} \PY{o}{<} \PY{n+no}{ActiveRecord}\PY{o}{::}\PY{n+no}{Base}
  \PY{n}{belongs\PYZus{}to} \PY{l+s+ss}{:user}
\PY{k}{end}
\end{ruby}
\codecaption{Nutzung von Metaprogrammierung zur Erstellung von Objektbeziehungen}
% label{fig:a7720a}

Hiermit definieren wir, dass ein Job einem User gehört, es also eine 1:N (oder 1:1)-Beziehung zwischen beiden gibt. Die dafür benötigten Getter und Setter werden mittels des Methodenaufrufs "`belongs\_to"' in die Klasse Job geschrieben.

Diese Beispiele sollten als kurzer Einstieg in Ruby dienen, und einen Querschnitt durch die Besonderheiten der Sprache aufzuzeigen.

Für eine weitere Vertiefung sei das Buch "`Programming Ruby 1.9"' empfohlen, das im Detail auf die neuste Version der Programmiersprache eingeht \citep{hunt_programming_2009}.



\subsection{Diskussion}

\paragraph{Ruby als Skriptsprache}
Dynamisch typisierte Sprachen, wie Ruby, haben gegenüber klassischen statisch-getypisierten Sprachen einige Nachteile. Oft wird der Geschwindigkeitsnachteil angesprochen, den der Prozess des Interpretierens und die dynamische Typisierung verursachen. 
Der genaue Faktor variiert allerdings je nach Algorithmus und Implementierung, stark. Ein beliebter Benchmark, "`shootout.alioth"', vergleicht beliebte Algorithmen der Informatik implementiert in verschiedenen Sprachen miteinander. So ergibt sich z.B. in der Gegenüberstellung von Ruby mit C ein 4 bis 300-fache langsamere Ausführungszeit. Dem gegenüber steht allerdings nur die Hälfte bis $1/7$ der Menge an benötigtem Code \citep{computer_language_benchmarks_game_ruby_2011}, was ein Zeichen für die Ausdrucksstärke von Ruby ist. Wichtig ist auch die verwendete Laufzeitumgebung. Neben der Referenzimplementierung von Matsumotu (Ruby MRI), existieren noch JRuby, eine Implementierung auf der Java Virtuellen Maschine, und Rubinius. Die letzten beiden unterstützen auch eine sogenannte Just-in-time (JIT)-Kompilierung zur Verbesserung der Performanz bei längerer Ausführungszeit. Desweiteren gibt es gerade im Bereich Performanz viel Bewegung innerhalb der Ruby-Implementierungen, und fast alle Ruby-Implementierungen nehmen stetigt zu \citep{antonio_cangiano_great_2010}.

Ein Vorteil des Interpretierens, also der Übersetzung zur Laufzeit, ist eine hohe Plattformunabhängigkeit und ein leichterer Buildprozess, da das Kompilieren entfällt. 
Verfechter dynamischer Sprachen erklären weiterhin, dass diese sich ideal für prototypische Implementierungen eignen, da sich Anforderungen ständig ändern können. Weiterhin hätten Programme dynamischer Sprache eine potenziell hohe Wiederverwendbarkeit und eine höhere Lesbarkeit \citep{meijer_static_2005} \citep{ousterhout_scripting:_1998}.

Allerdings bleiben Fehler, die der Compiler bereits entdeckt hätte, bis zur Ausführung oder schlimmstenfalls noch länger unentdeckt. Dazu gehören z.B. Tippfehler, bei denen der Wert einer nicht deklarierten Variable ausgelesen wird. Im Gegensatz zu z.B. PHP, wirft Ruby aber dann eine Exception.

Auf das Testen hat dies eine direkte Auswirkung. Viele Meinungen belegen, dass eine dynamisch typisierte Sprache mehr Tests benötigt, als eine statisch typisierte \citep{daniel_spiewak_dynamic_2010}. 

% 
% All diese Methoden können, richtig angewendet, zur Verbesserung der Lesbarkeit der Programme, und damit zur Erhöhrung der Wartbarkeit, führen.
% 
% Auch das sehr beliebte Testframework Rspec, verwendet Metaprogrammierung, um Testfälle und Zusicherungen wie fast in der englischen Sprache zu formulieren. Dazu werden sämtliche Objekte von Ruby um Funktionen erweitert. Dies ist möglich, da die Klasse "`Objekt"', die Basisklasse (fast) aller Ruby-Klasse ist, um diese Methoden erweitert wurde.
% 

\paragraph{Schlussfolgerung}

Die Verwendung von Ruby und anderen dynamischen Sprachen birgt durchaus Risiken, die zu beachten sind. Falls man diese Risiken im Kopf behält, und die Möglichkeiten der Sprache nutzt, um die Lesbarkeit zu verbessern, sind sie gerechtfertigt. Gerade in der Entwicklung kleinerer Entwicklerteams oder Projekten mit engem Budget können dynamische Sprachen ihre Vorteile ausspielen, da sie eine eine schnellere Entwicklung ermöglicht. Im Gegensatz zu den meisten auf C basierten Sprachen, ist die Syntax von Ruby äußerst leserlich, da nur wenige Sonderzeichen verwendet werden. Auch ist Ruby sehr ausdrucksstark, da die Deklaration entfällt und es viel sogenannten syntaktischen Zucker gibt. Dies kann, richtig angewendet, der Lesbarkeit zuträglich sein.

\epigraph{Sometimes people jot down pseudo-code on paper. If that pseudo-code runs directly on their computers, it's best, isn't it? Ruby tries to be like that, like pseudo-code that runs. }{Yukihiro Matsumoto}


\subsection{Testframeworks für Ruby}
\subsubsection{Test::Unit und Minitest}
Test::Unit (Ruby 1.8.7) und Minitest (1.9.2) sind die Testbibliotheken, die Ruby standardmäßig mitbringt. Beide basieren auf dem xUnit-, bzw. SUnit-Design von Kent Beck, und sind für Nutzer von JUnit oder NUnit leicht nachvollziehbar. 

Für eine zu testende Klasse wird eine analoge Testklasse erstellt. Diese trägt per Definition denselben Namen wie die zu testende Klasse mit einem "`Test"' am Anfang. Um z.B. eine Klasse "`job"' zu testen, wird eine Datei \texttt{test\_job.rb} (Ruby Standard) oder \texttt{job\_test.rb} (Rails Standard) erstellt. Dort wiederrum wird eine Klasse mit Namen \texttt{TestJob} definiert. 

Ein Beispieltest sieht z.B. so aus:
% \begin{lstlisting}[language=Ruby,label=,caption=]
\begin{ruby}[label=Testen mit Test::Unit]
\PY{o}{[}\PY{n}{language}\PY{o}{=}\PY{n+no}{Ruby}\PY{p}{,}\PY{n}{label}\PY{o}{=}\PY{n+no}{Testen} \PY{n}{mit} \PY{n+no}{Test}\PY{o}{::}\PY{n+no}{Unit}\PY{p}{,}\PY{n}{caption}\PY{o}{=}\PY{n+no}{Testen} \PY{n}{mit} \PY{n+no}{Test}\PY{o}{::}\PY{n+no}{Unit} \PY{k}{in} \PY{n+no}{Ruby}\PY{o}{]}
\PY{n+nb}{require} \PY{l+s+s2}{"}\PY{l+s+s2}{job}\PY{l+s+s2}{"}

\PY{k}{class} \PY{n+nc}{TestJob} \PY{o}{<} \PY{n+no}{Test}\PY{o}{::}\PY{n+no}{Unit}\PY{o}{::}\PY{n+no}{TestCase}
  \PY{k}{def} \PY{n+nf}{setup}
    \PY{n+nv+vi}{@job} \PY{o}{=} \PY{n+no}{Job}\PY{o}{.}\PY{n}{create}
  \PY{k}{end}
  
  \PY{k}{def} \PY{n+nf}{teardown}
    \PY{n+no}{Job}\PY{o}{.}\PY{n}{delete\PYZus{}all}
  \PY{k}{end}
  
  \PY{k}{def} \PY{n+nf}{test\PYZus{}job\PYZus{}exists}
    \PY{n+nv+vi}{@job}\PY{o}{.}\PY{n}{title} \PY{o}{=}  \PY{l+s+s2}{"}\PY{l+s+s2}{Ruby on Rails in Entwickler}\PY{l+s+s2}{"}
    \PY{n+nv+vi}{@job}\PY{o}{.}\PY{n}{add\PYZus{}location\PYZus{}to\PYZus{}title}\PY{p}{(} \PY{l+s+s2}{"}\PY{l+s+s2}{Dresden}\PY{l+s+s2}{"}\PY{p}{)}
    
    \PY{n}{assert\PYZus{}equal}\PY{p}{(} \PY{l+s+s2}{"}\PY{l+s+s2}{Ruby on Rails Entwickler in Dresden}\PY{l+s+s2}{"}\PY{p}{,}  \PY{n+no}{Job}\PY{o}{.}\PY{n}{first}\PY{o}{.}\PY{n}{title}\PY{p}{)}
  \PY{k}{end}
\PY{k}{end}
\end{ruby}
\codecaption{Testen mit Test::Unit in Ruby}

Unsere Klasse TestJob erbt von der TestUnit Basisklasse. Sie beinhaltet die Methoden "`setup"' und "`teardown"', die jeweils vor, respektive nach jedem einzelnen Testfall aufgerufen werden.
In der Setup-Methode nehmen wir z.B. das Anlegen eines Jobs vor, in der Teardown Methode löschen wir alle Jobs in der Datenbank, um einen sauberen Test zu gewährleisten

Danach können nun beliebig viele Testmethoden folgen, deren Namen mit \texttt{test\_} beginnen müssen.
Jede Testmethode besteht in der Regel aus einer Initialisierung (kann in die setup-Methode ausgelagert werden), der Ausführung einer zu testenden Aktion und dem Prüfen der danach geltenden Eigenschaften mittels Assertions. Diese Zusicherungen sind z.B.:
\begin{description}
 \item[assert\_equal(a, b)] prüft die beiden Parameter auf Gleichheit
 \item[assert(a)] Prüft, ob a wahr ist
 \item[assert\_raise(exception, \&block)] Prüft, ob innerhalb des übergebenen Codestückes eine Exception vom Typ exception geworfen wird
\end{description}
%TODO Mehr Assertions und konkreter erklaeren, was sind a und b. Semantik: Falls Eingabe gleich (was bedeutet gleichheit)
Natürlich lassen sich beliebige weitere Zusicherungen definieren. \glossar{rails} z.B. definiert Zusicherungen, um zu testen, ob ein Objekt eine gültige Instanz hinsichtlich der definierten Validierungen ist (zum Thema Validierungen später mehr).

\paragraph{Testdatengenerierung}
Nachdem Testdaten einmal in zentraler Form definiert wurden, erledigt \glossar{rails} das Management, d.h. Laden und Löschen dieser selbständig. Diese Art der Testdatenbereitstellung wird als Fixtures bezeichnet. Alternativ ist der Einsatz sogenannter Factories möglich, um schnell Objekte mit bestimmten Eigenschaften zu erstellen. In jedem Fall setzt Rails die Datenbank nach jedem einzelnen Test zurück, oder kapselt Tests innerhalb von Transaktionen, insofern die verwendete Datenbank dies unterstützt.
%TODO Abschnitt ueberarbeiten 
% laedt definierte Objekte, andere Eigenschaften??  Wie waehlt man Testdaten aus??

Zur Generierung von größeren Mengen an zufälligen Daten einer bestimmten Domän (z.B. für Stresstests) existieren Lösungen. Mittels der \glossarpl{gem} "`populator"' und "`faker"' lassen sich beispielsweise eine beliebige Menge an gültig-anscheinenden Personendaten (Name, Vorname, Adresse, E-Mail-Adresse, Passwort,...) oder Blind-Texte generieren\footnote{Eine sehr gute Erklärung der Nutzung ist im Railscast \#128 zu finden \url{http://railscasts.com/episodes/126-populating-a-database}}.


\subsubsection{Cucumber}
\label{sec:cucumber}
Cucumber ist ein relativ neues Framework (2008), um mittels einer domainspezifischen Sprache verständliche automatisierte Tests zu schreiben. Dabei gibt es 2 Ebenen. In der obersten werden Tests in Englisch, Deutsch oder einer anderen der mehr als 30 unterstützten Sprachen spezifiziert. In der darunterliegenden werden diese Schritte in echten Testcode implementiert. Im Folgenden sei ein Trivialbeispiel einer Anwendung, die Addieren unterstützt gezeigt.

\lstinputlisting[label=Cucumber: Additionsfeature in Deutsch,caption=Cucumber: Additionsfeature in Deutsch]{listings/addition.feature}

Wenn man nun die Datei mittels Cucumber ausführt, so wird darauf hingewiesen, dass die Testschritte noch nicht implementiert sind.
Eine Beispielimplementation (ohne Verwendung einer GUI-Anwendung) der Testschritte wäre:

\lstinputlisting[label=Cucumber: Implementierung der Additionstestschritte in Ruby,caption=Cucumber: Implementierung der Additionstestschritte in Ruby]{listings/steps.rb}

Wie man sehen können werden die Testschritte über Regex gemacht. Jeder Schritt kann nun eine beliebige Implementierung besitzen. Meist ist es entweder eine Initialisierung, eine Aktion oder eine Erwartung, ausgedrückt durch die Schlüsselwörter "`Angenommen"', "`Wenn"' und "`Dann"', bzw. "`Given"', "`When"' und "`Then"' im Originaldialekt. Die Einteilung in klare Testschritte fördert die Wiederverwendbarkeit der Testschritte selbst.

Der Vorteil von Cucumber ist nun, dass diese Feature-Datei zusammen mit dem Kunden durchgesprochen werden kann, und am Ende eine funktionale Validierung durchzuführen- Auch hilft es, nur diejenigen Features zu implementieren, die letztendlich einen Wert für das Geschäft haben werden. 
 
In der Regel werden mit Cucumber Webanwendungen getestet. Dabei kann z.B. auch ein echter Browser ferngesteuert werden, um den Test so authentisch am echten Nutzungsprozess wie möglich zu orientieren. 

Neben Ruby wird auch die Implementierung der Testschritte in JVM und .NET-Sprachen unterstützt.